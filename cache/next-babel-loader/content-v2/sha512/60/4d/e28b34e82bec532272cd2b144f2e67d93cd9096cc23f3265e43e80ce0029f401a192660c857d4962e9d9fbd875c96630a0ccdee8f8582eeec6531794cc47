{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.noSSR = noSSR;\nexports.default = dynamic;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _loadable = _interopRequireDefault(require(\"./loadable\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst isServerSide = true;\n\nfunction noSSR(LoadableInitializer, loadableOptions) {\n  // Removing webpack and modules means react-loadable won't try preloading\n  delete loadableOptions.webpack;\n  delete loadableOptions.modules; // This check is necessary to prevent react-loadable from initializing on the server\n\n  if (!isServerSide) {\n    return LoadableInitializer(loadableOptions);\n  }\n\n  const Loading = loadableOptions.loading; // This will only be rendered on the server side\n\n  return () => /*#__PURE__*/_react.default.createElement(Loading, {\n    error: null,\n    isLoading: true,\n    pastDelay: false,\n    timedOut: false\n  });\n}\n\nfunction dynamic(dynamicOptions, options) {\n  let loadableFn = _loadable.default;\n  let loadableOptions = {\n    // A loading component is not required, so we default it\n    loading: ({\n      error,\n      isLoading,\n      pastDelay\n    }) => {\n      if (!pastDelay) return null;\n\n      if (true) {\n        if (isLoading) {\n          return null;\n        }\n\n        if (error) {\n          return /*#__PURE__*/_react.default.createElement(\"p\", null, error.message, /*#__PURE__*/_react.default.createElement(\"br\", null), error.stack);\n        }\n      }\n\n      return null;\n    }\n  }; // Support for direct import(), eg: dynamic(import('../hello-world'))\n  // Note that this is only kept for the edge case where someone is passing in a promise as first argument\n  // The react-loadable babel plugin will turn dynamic(import('../hello-world')) into dynamic(() => import('../hello-world'))\n  // To make sure we don't execute the import without rendering first\n\n  if (dynamicOptions instanceof Promise) {\n    loadableOptions.loader = () => dynamicOptions; // Support for having import as a function, eg: dynamic(() => import('../hello-world'))\n\n  } else if (typeof dynamicOptions === 'function') {\n    loadableOptions.loader = dynamicOptions; // Support for having first argument being options, eg: dynamic({loader: import('../hello-world')})\n  } else if (typeof dynamicOptions === 'object') {\n    loadableOptions = _objectSpread(_objectSpread({}, loadableOptions), dynamicOptions);\n  } // Support for passing options, eg: dynamic(import('../hello-world'), {loading: () => <p>Loading something</p>})\n\n\n  loadableOptions = _objectSpread(_objectSpread({}, loadableOptions), options);\n  const suspenseOptions = loadableOptions;\n\n  if (!process.env.__NEXT_CONCURRENT_FEATURES) {\n    // Error if react root is not enabled and `suspense` option is set to true\n    if (!process.env.__NEXT_REACT_ROOT && suspenseOptions.suspense) {\n      // TODO: add error doc when this feature is stable\n      throw new Error(`Invalid suspense option usage in next/dynamic. Read more: https://nextjs.org/docs/messages/invalid-dynamic-suspense`);\n    }\n  }\n\n  if (suspenseOptions.suspense) {\n    return loadableFn(suspenseOptions);\n  } // coming from build/babel/plugins/react-loadable-plugin.js\n\n\n  if (loadableOptions.loadableGenerated) {\n    loadableOptions = _objectSpread(_objectSpread({}, loadableOptions), loadableOptions.loadableGenerated);\n    delete loadableOptions.loadableGenerated;\n  } // support for disabling server side rendering, eg: dynamic(import('../hello-world'), {ssr: false})\n\n\n  if (typeof loadableOptions.ssr === 'boolean') {\n    if (!loadableOptions.ssr) {\n      delete loadableOptions.ssr;\n      return noSSR(loadableFn, loadableOptions);\n    }\n\n    delete loadableOptions.ssr;\n  }\n\n  return loadableFn(loadableOptions);\n}","map":{"version":3,"sources":["../../../shared/lib/dynamic.tsx"],"names":[],"mappings":";;;;;;;;;;;QAkDgB,K,GAAA,K;kBAoBQ,O;;AAtEN,IAAA,MAAO,GAAA,sBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAP;;AACG,IAAA,SAAY,GAAA,sBAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAZ;;;;;;;;AAErB,MAAM,YAAY,OAAlB;;SA+CgB,K,CACd,mB,EACA,e,EACwB;AACxB;SACO,eAAe,CAAC,O;SAChB,eAAe,CAAC,O,CAHC,CAKxB;;AACA,MAAE,CAAG,YAAL,EAAmB;WACV,mBAAmB,CAAC,eAAD,C;AAC3B;;AAED,QAAM,OAAO,GAAG,eAAe,CAAC,OAAhC,CAVwB,CAWxB;;4BAhEgB,MAAO,CAAA,OAAP,CAAO,aAAP,CAkEb,OAlEa,EAkEN;AAAC,IAAA,KAAK,EAAE,IAAR;AAAc,IAAA,SAAS,EAAT,IAAd;AAAwB,IAAA,SAAS,EAAE,KAAnC;AAA0C,IAAA,QAAQ,EAAE;AAApD,GAlEM,C;AAoEjB;;SAEuB,O,CACtB,c,EACA,O,EACwB;AACxB,MAAI,UAAU,GAzEK,SAAY,CAAA,OAyE/B;AACA,MAAI,eAAe,GAAA;AACjB;AACA,IAAA,OAAO,EAAA,CAAA;AAAK,MAAA,KAAL;AAAY,MAAA,SAAZ;AAAuB,MAAA;AAAvB,KAAA,KAAuC;AAC5C,UAAE,CAAG,SAAL,EAAc,OAAS,IAAT;;AACd,gBAA4C;AAC1C,YAAI,SAAJ,EAAe;iBACN,I;AACR;;AACD,YAAI,KAAJ,EAAW;8BAnFD,MAAO,CAAA,OAAP,CAAO,aAAP,CAAO,GAAP,EAqFJ,IArFI,EAsFH,KAAK,CAAC,OAtFH,EAsFU,aAtFV,MAAO,CAAA,OAAP,CAAO,aAAP,CAAO,IAAP,EAuFD,IAvFC,CAAA,EAwFH,KAAK,CAAC,KAxFH,C;AA2FT;AACF;;aAEM,I;AACR;AApBgB,GAAnB,CAFwB,CAyBxB;AACA;AACA;AACA;;AACA,MAAI,cAAc,YAAY,OAA9B,EAAuC;AACrC,IAAA,eAAe,CAAC,MAAhB,GAAsB,MAAS,cAA/B,CADqC,CAErC;;AACD,GAHD,MAGO,IAAE,OAAS,cAAT,KAAuB,UAAzB,EAA0C;AAC/C,IAAA,eAAe,CAAC,MAAhB,GAAyB,cAAzB,CAD+C,CAE/C;AACD,GAHM,MAGA,IAAE,OAAS,cAAT,KAAuB,QAAzB,EAAwC;AAC7C,IAAA,eAAe,mCAAQ,eAAR,GAA4B,cAA5B,CAAf;AACD,GArCuB,CAuCxB;;;AACA,EAAA,eAAe,mCAAQ,eAAR,GAA4B,OAA5B,CAAf;AAEA,QAAM,eAAe,GAAG,eAAxB;;AACA,MAAE,CAAG,OAAO,CAAC,GAAR,CAAY,0BAAjB,EAA6C;AAC3C;AACA,QAAE,CAAG,OAAO,CAAC,GAAR,CAAY,iBAAf,IAAoC,eAAe,CAAC,QAAtD,EAAgE;AAC9D;AACA,YAAM,IAAI,KAAJ,CACH,qHADG,CAAN;AAGD;AACF;;AACD,MAAI,eAAe,CAAC,QAApB,EAA8B;WACrB,UAAU,CAAC,eAAD,C;AAClB,GAtDuB,CAwDxB;;;AACA,MAAI,eAAe,CAAC,iBAApB,EAAuC;AACrC,IAAA,eAAe,mCACV,eADU,GAEV,eAAe,CAAC,iBAFN,CAAf;WAIO,eAAe,CAAC,iB;AACxB,GA/DuB,CAiExB;;;AACA,MAAE,OAAS,eAAe,CAAC,GAAzB,KAA4B,SAA9B,EAA8C;AAC5C,QAAE,CAAG,eAAe,CAAC,GAArB,EAA0B;aACjB,eAAe,CAAC,G;aAChB,KAAK,CAAC,UAAD,EAAa,eAAb,C;AACb;;WACM,eAAe,CAAC,G;AACxB;;SAEM,UAAU,CAAC,eAAD,C;AAClB","sourcesContent":["import React from 'react'\nimport Loadable from './loadable'\n\nconst isServerSide = typeof window === 'undefined'\n\nexport type LoaderComponent<P = {}> = Promise<\n  React.ComponentType<P> | { default: React.ComponentType<P> }\n>\n\nexport type Loader<P = {}> = (() => LoaderComponent<P>) | LoaderComponent<P>\n\nexport type LoaderMap = { [mdule: string]: () => Loader<any> }\n\nexport type LoadableGeneratedOptions = {\n  webpack?(): any\n  modules?(): LoaderMap\n}\n\nexport type LoadableBaseOptions<P = {}> = LoadableGeneratedOptions & {\n  loading?: ({\n    error,\n    isLoading,\n    pastDelay,\n  }: {\n    error?: Error | null\n    isLoading?: boolean\n    pastDelay?: boolean\n    retry?: () => void\n    timedOut?: boolean\n  }) => JSX.Element | null\n  loader?: Loader<P> | LoaderMap\n  loadableGenerated?: LoadableGeneratedOptions\n  ssr?: boolean\n}\n\nexport type LoadableSuspenseOptions<P = {}> = {\n  loader: Loader<P>\n  suspense?: boolean\n}\n\nexport type LoadableOptions<P = {}> = LoadableBaseOptions<P>\n\nexport type DynamicOptions<P = {}> = LoadableBaseOptions<P>\n\nexport type LoadableFn<P = {}> = (\n  opts: LoadableOptions<P> | LoadableSuspenseOptions<P>\n) => React.ComponentType<P>\n\nexport type LoadableComponent<P = {}> = React.ComponentType<P>\n\nexport function noSSR<P = {}>(\n  LoadableInitializer: LoadableFn<P>,\n  loadableOptions: LoadableBaseOptions<P>\n): React.ComponentType<P> {\n  // Removing webpack and modules means react-loadable won't try preloading\n  delete loadableOptions.webpack\n  delete loadableOptions.modules\n\n  // This check is necessary to prevent react-loadable from initializing on the server\n  if (!isServerSide) {\n    return LoadableInitializer(loadableOptions)\n  }\n\n  const Loading = loadableOptions.loading!\n  // This will only be rendered on the server side\n  return () => (\n    <Loading error={null} isLoading pastDelay={false} timedOut={false} />\n  )\n}\n\nexport default function dynamic<P = {}>(\n  dynamicOptions: DynamicOptions<P> | Loader<P>,\n  options?: DynamicOptions<P>\n): React.ComponentType<P> {\n  let loadableFn: LoadableFn<P> = Loadable\n  let loadableOptions: LoadableOptions<P> = {\n    // A loading component is not required, so we default it\n    loading: ({ error, isLoading, pastDelay }) => {\n      if (!pastDelay) return null\n      if (process.env.NODE_ENV === 'development') {\n        if (isLoading) {\n          return null\n        }\n        if (error) {\n          return (\n            <p>\n              {error.message}\n              <br />\n              {error.stack}\n            </p>\n          )\n        }\n      }\n\n      return null\n    },\n  }\n\n  // Support for direct import(), eg: dynamic(import('../hello-world'))\n  // Note that this is only kept for the edge case where someone is passing in a promise as first argument\n  // The react-loadable babel plugin will turn dynamic(import('../hello-world')) into dynamic(() => import('../hello-world'))\n  // To make sure we don't execute the import without rendering first\n  if (dynamicOptions instanceof Promise) {\n    loadableOptions.loader = () => dynamicOptions\n    // Support for having import as a function, eg: dynamic(() => import('../hello-world'))\n  } else if (typeof dynamicOptions === 'function') {\n    loadableOptions.loader = dynamicOptions\n    // Support for having first argument being options, eg: dynamic({loader: import('../hello-world')})\n  } else if (typeof dynamicOptions === 'object') {\n    loadableOptions = { ...loadableOptions, ...dynamicOptions }\n  }\n\n  // Support for passing options, eg: dynamic(import('../hello-world'), {loading: () => <p>Loading something</p>})\n  loadableOptions = { ...loadableOptions, ...options }\n\n  const suspenseOptions = loadableOptions as LoadableSuspenseOptions<P>\n  if (!process.env.__NEXT_CONCURRENT_FEATURES) {\n    // Error if react root is not enabled and `suspense` option is set to true\n    if (!process.env.__NEXT_REACT_ROOT && suspenseOptions.suspense) {\n      // TODO: add error doc when this feature is stable\n      throw new Error(\n        `Invalid suspense option usage in next/dynamic. Read more: https://nextjs.org/docs/messages/invalid-dynamic-suspense`\n      )\n    }\n  }\n  if (suspenseOptions.suspense) {\n    return loadableFn(suspenseOptions)\n  }\n\n  // coming from build/babel/plugins/react-loadable-plugin.js\n  if (loadableOptions.loadableGenerated) {\n    loadableOptions = {\n      ...loadableOptions,\n      ...loadableOptions.loadableGenerated,\n    }\n    delete loadableOptions.loadableGenerated\n  }\n\n  // support for disabling server side rendering, eg: dynamic(import('../hello-world'), {ssr: false})\n  if (typeof loadableOptions.ssr === 'boolean') {\n    if (!loadableOptions.ssr) {\n      delete loadableOptions.ssr\n      return noSSR(loadableFn, loadableOptions)\n    }\n    delete loadableOptions.ssr\n  }\n\n  return loadableFn(loadableOptions)\n}\n"]},"metadata":{},"sourceType":"script"}